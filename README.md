# **Оглавление**

- [Общая информация](#pyxration)
- [Модуль *stringolist*, его классы, функции и методы](#модуль-stringolist-его-классы-функции-и-методы)
  - [Класс *stringolist* (строко-список) и создание его экземпляров](#класс-stringolist-строко-список-и-создание-его-экземпляров)
    - [Добавление новых объектов в *stringolist*-экземпляр](#добавление-новых-объектов-в-stringolist-экземпляр)
    - [Операции над строко-списками](#операции-над-строко-списками)
    - [Получение объекта по ключу или срезу](#получение-объекта-по-ключу-или-срезу)
    - [Перечисление в цикле *for*](#перечисление-в-цикле-for)
    - [Проверка принадлежности](#проверка-принадлежности)
    - [Поиск объектов и подстроко-списков](#поиск-объектов-и-подстроко-списков)
    - [Замена подстроко-списка другим](#замена-подстроко-списка-другим)
    - [Разбитие строко-списка на строко-списки](#разбитие-строко-списка-на-строко-списки)
- [Модуль *exprtree*, его классы, функции и методы](#модуль-exprtree-его-классы-функции-и-методы)
  - [Класс *operation* (операция) и создание его экземпляров](#класс-operation-операция-и-создание-его-экземпляров)
  - [Класс *exprtree* (операционное дерево) и создание его экземпляров](#класс-exprtree-операционное-дерево-и-создание-его-экземпляров)
    - [Вывод операционного дерева](#вывод-операционного-дерева)
  - [Класс *algebra* (алгебра) и создание его экземпляров](#класс-algebra-алгебра-и-создание-его-экземпляров)
    - [Создание операционного выражения с помощью алгебры](#создание-операционного-выражения-с-помощью-алгебры)
    - [Конвертация операционного дерева выражения обратно в строку выражения](#конвертация-операционного-дерева-выражения-обратно-в-строку-выражения)
- [Модуль *functree*, его классы, функции и методы](#модуль-functree-его-классы-функции-и-методы)
  - [Класс *funcparam* (параметр функции-дерева) и создание его экземпляров](#класс-funcparam-параметр-функции-дерева-и-создание-его-экземпляров)
  - [Класс *functree* (функция-дерево) и создание его экземпляров](#класс-functree-функция-дерево-и-создание-его-экземпляров)
    - [Конвертация функции-дерева обратно в строку выражения](#конвертация-функции-дерева-обратно-в-строку-выражения)
    - [Подстановка значений вместо параметров](#подстановка-значений-вместо-параметров)
- [Модуль *exprhandler*, его классы, функции и методы](#модуль-exprhandler-его-классы-функции-и-методы)
  - [Функция *invertOperPreparser*](#функция-invertOperPreparser)
  - [Функция *invertOperPoststringifier*](#функция-invertOperPoststringifier)
- [Модуль *transtree*, его классы, функции и методы](#модуль-transtree-его-классы-функции-и-методы)
  - [Функция *apply*](#функция-apply)
  - [Функция *operation_sort*](#функция-operation_sort)
  - [Функция *expression_replacer*](#функция-expression_replacer)
  - [Функция *neutrals_deleter*](#функция-neutrals_deleter)
  - [Функция *zero_absorber*](#функция-zero_absorber)

## *pyxration*
Символьная алгебраическая библиотека для создания и описания своих алгебраических систем.

Позволяет создавать свои операции, объекты, алгебры, использующие эти операции и объекты, и преобразования выражений (переходы от одного выражения к другому).

## Модуль *stringolist*, его классы, функции и методы
Модуль, который позволяет работать со строко-списками - гибрид строки и списка. Является Python-списком, но имеет в себе методы Python-строки. Таким образом можно искать "подсписок" (подстроко-список) у данного строко-списка. Строко-список можно понимать, как Python-строку, которая вместо символов содержит любые объекты.

### Класс *stringolist* (строко-список) и создание его экземпляров
Класс позволяет создавать списки разных элементов и работать с этими списками как со строками. Возможность хранить любые объекты в качестве элементов в *stringolist*-объектах даёт возможность заменять часть строки, представленной в виде *stringolist*-объекта на какой-нибудь обработанный объект.

Для создания строко-списка в конструктор в качестве параметра нужно подать список, либо подать сразу несколько объектов:
```python
s = stringolist(0, 1.1, 'abc', None)            # stringolist([0, 1.1, 'abc', None])
len(s)                                          # 4
helloList = stringolist(list('Hello world!'))   # stringolist(['H', 'e', 'l', 'l', 'o', ' ', 'w', 'o', 'r', 'l', 'd', '!'])
len(helloList)                                  # 12
helloStr = stringolist('Hello world')           # stringolist(['Hello world'])
len(helloStr)                                   # 1
```
Количество параметров, поданных в конструктор, приоритетнее значения первого параметра:
```python
a = stringolist([1, 2, 3], 'abc')   # stringolist([[1, 2, 3], 'abc'])
len(a)                              # 2
b = stringolist([[1, 2, 3]])        # stringolist([[1, 2, 3]])
len(b)                              # 1
```

#### Добавление новых объектов в *stringolist*-экземпляр
Добавление новых элементов производится так же как и в список:
```python
a = stringolist(list('Hell'))   # stringolist(['H', 'e', 'l', 'l'])
a.append('o')
a                               # stringolist(['H', 'e', 'l', 'l', 'o'])
```

#### Операции над строко-списками
Операции сложения и умножения над строко-списками такие же как и над строками или списками в Python.
```python
a = stringolist(1, 2, 3)    # stringolist([1, 2, 3])
b = stringolist(4, 5, 6)    # stringolist([4, 5, 6])
a + b                       # stringolist([1, 2, 3, 4, 5, 6])
a * 3                       # stringolist([1, 2, 3, 1, 2, 3, 1, 2, 3])
b * 0                       # stringolist([])
b * -1                      # stringolist([])
```

#### Получение объекта по ключу или срезу
Получение объекта по ключу или срезу работает как и для строк или списков:
```python
L = ['a', 'b', 'c', 'd', 'e', 'f']
S = stringolist(L.copy())           # чтобы случайно не изменить строко-список через переменную L, делаем её копию
S[0]                                # 'a'
S[3]                                # 'd'
S[-1]                               # 'f'
S[-4]                               # 'c'
S[1:4]                              # stringolist(['b', 'c', 'd'])
S[:2]                               # stringolist(['a', 'b'])
S[3:]                               # stringolist(['d', 'e', 'f'])
S[::2]                              # stringolist(['a', 'c', 'e'])
```

#### Перечисление в цикле *for*
Можно в цикле *for* поработать с каждым объектом данного строко-списка:
```python
nums = stringolist(list(range(10))) # stringolist([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
sqrs = stringolist()                # stringolist([])
for num in nums:
    sqrs.append(num ** 2)
sqrs                                # stringolist([0, 1, 4, 9, 16, 25, 36, 49, 64, 81])
```

#### Проверка принадлежности
Проверка принадлежности работает как для строки:
```python
s = stringolist(0, 'f', 23, 4.5, 'abc', None)   # stringolist([0, 'f', 23, 4.5, 'abc', None])
sub = stringolist('f', 23, 4.5)                 # stringolist(['f', 23, 4.5])
sub in s                                        # True
sub = stringolist('f', 4.5)                     # stringolist(['f', 4.5])
sub in s                                        # False
23 in s                                         # TypeError: must be stringolist, not int
```

#### Поиск объектов и подстроко-списков
Для поиска объектов в строко-списке как в списке используется метод *index*, а для поиска подстроко-списка используются *find* и *rfind*:
```python
s = stringolist(0, 1, 2, 0, 1, 2, 0, 1, 2)      # stringolist([0, 1, 2, 0, 1, 2, 0, 1, 2])
s.index(2)                                      # 2
sub = stringolist(2, 0, 1)                      # stringolist([2, 0, 1])
s.find(sub)                                     # 2
s.rfind(sub)                                    # 5
```

#### Замена подстроко-списка другим
Замена подстрокосписка другим производится методом *replace*. Сам строко-список не изменится. Этот метод работает подобно методу для строки:
```python
s = stringolist(list('apple  orange  watermelon'))  # stringolist(['a', 'p', 'p', 'l', 'e', ' ', ' ', 'o', 'r', 'a', 'n', 'g', 'e', ' ', ' ', 'w', 'a', 't', 'e', 'r', 'm', 'e', 'l', 'o', 'n'])
old = stringolist(list('  '))                       # stringolist([' ', ' '])
new = stringolist(list(', '))                       # stringolist([',', ' '])
s.replace(old, new)                                 # stringolist(['a', 'p', 'p', 'l', 'e', ',', ' ', 'o', 'r', 'a', 'n', 'g', 'e', ',', ' ', 'w', 'a', 't', 'e', 'r', 'm', 'e', 'l', 'o', 'n'])
new = stringolist(list(' '))                        # stringolist([' '])
s.replace(old, new)                                 # stringolist(['a', 'p', 'p', 'l', 'e', ' ', 'o', 'r', 'a', 'n', 'g', 'e', ' ', 'w', 'a', 't', 'e', 'r', 'm', 'e', 'l', 'o', 'n'])
```

#### Разбитие строко-списка на строко-списки
Разбитие строко-списка на строко-списки производится методом *split*, как это делается и для строк:
```python
s = stringolist(list('apple  orange  watermelon'))  # stringolist(['a', 'p', 'p', 'l', 'e', ' ', ' ', 'o', 'r', 'a', 'n', 'g', 'e', ' ', ' ', 'w', 'a', 't', 'e', 'r', 'm', 'e', 'l', 'o', 'n'])
sep = stringolist(list('  '))                       # stringolist([' ', ' '])
s.split(sep)                                        # [stringolist(['a', 'p', 'p', 'l', 'e']), stringolist(['o', 'r', 'a', 'n', 'g', 'e']), stringolist(['w', 'a', 't', 'e', 'r', 'm', 'e', 'l', 'o', 'n'])]
```

## Модуль *exprtree*, его классы, функции и методы
Модуль, который позволяет создавать свои операции, строить с помощью них алгебру и задавать выражения с помощью уже алгебры.

### Класс *operation* (операция) и создание его экземпляров
Экземпляры класса *operation* - операции или объекты. Их можно создать, если подать в конструктор имя операции или объекта (и функции парсировки и представления операции или объекта в строковом выражении, если они имеются):
```python
addition = operation('addition')
multiplication = operation('multiplication')
```

При создании своей функции парсировки операции или объекта нужно учитывать, что эта функция должна принимать только строко-список, а возвращать строко-список или операционное дерево (о нём позже), если функция нашла в строко-списке вашу операцию или объект и произвела замену всего строко-списка или частично, иначе - *None*.

При создании своей функции представления операции или объекта нужно учитывать, что эта функция должна принимать только список операционных деревьев, а возвращать строку - строковое представление применения операции к списку объектов.

Для добавления функции парсировки и представления операции достаточно подать эти функции в метод "funcs_update" по одному или в кортеже. Есть готовые шаблоны этих функций, можно воспользоваться ими:
```python
addition.funcs_update(infix_parser_and_repres('+', addition))
multiplication.funcs_update(infix_parser_and_repres('*', multiplication))
```

Для быстрого создания операции или объекта можно воспользоваться готовыми функциями:
```python
plus = operInfix('addition', '+')
minus = operPrefix('negative', '-')
group = operGrouping('()', '(', ')')
integer = operObject('integer',
                     lambda x: x.is_str() and x.to_str().isdigit(),
                     lambda x: int(x.to_str()),
                     lambda x: str(x))
```

### Класс *exprtree* (операционное дерево) и создание его экземпляров
Экземпляры класса *exprtree* - операционные деревья выражений. Их можно создать, если подать в конструктор операцию и список операционных деревьев (если текущая операция - объект, то в качестве списка операционных деревьев подаётся одноэлементный список со значением текущего объекта):
```python
unit = exprtree(integer, [1])
sum_expr = exprtree(plus, [unit.copy(), unit.copy(), unit.copy()])
```

Можно создавать копии операционных деревьев с помощью метода *copy*:
```python
other_expr = sum_expr.copy()
```

#### Вывод операционного дерева
Функция *str_tree* вернёт строковое представления операционного дерева выражения на боку. Можно подать в качестве дополнительного параметра *True*, чтобы получить типы объектов:
```python
print(str_tree(sum_expr))
```
```text
[addition]
├[integer]
│└1
├[integer]
│└1
└[integer]
 └1
```
```python
print(str_tree(sum_expr, True))
```
```text
[addition] is exprtree
├[integer] is exprtree
│└1 is int
├[integer] is exprtree
│└1 is int
└[integer] is exprtree
 └1 is int
```

### Класс *algebra* (алгебра) и создание его экземпляров
Экземпляры класса *algebra* - алгебры со своими операциями и правилами. Их можно создать, если подать в конструктор имя алгебры и список операций, который задаёт порядок парсировки этих операций в строковом выражении. Также можно подать список операций, который задаёт порядок выполнения выражения, и группирующую операцию, чтобы сгруппировать подвыражения при конвертации из операционного дерева в строку, тем самым задав порядок выполнения выражения.
```python
simple_algebra = algebra('simple', [group, plus, minus, integer], [integer, minus, plus, group], group)
```

Для операций созданных по готовым шаблонам порядок парсировки предлагается такой:

1. Группирующие операции в порядке, в котором первыми идут операции, открывающая и закрывающая части которых не являются подстроками открывающих и закрывающих частей других группирующих операций.
2. Инфиксные операции в порядке, обратном порядку выполнения математического выражения.
3. Префиксные операции в порядке, в котором первыми идут операции, префиксное обозначение которых не является началом префиксного обозначения других префиксных операций.
4. Операции-объекты в порядке, в котором другой объект не воспримется за объект текущего типа операции-объекта.

#### Создание операционного выражения с помощью алгебры
Алгебры используются для создания операционных деревьев из строки. Для этого нужно сначала создать операции как написано выше, затем создать алгебру из этих операций, после этого можно создавать операционные деревья из строки с помощью метода *new_expr*:
```python
simple_expr = simple_algebra.new_expr('1+2+-3+(7+-5)')
print(str_tree(simple_expr))
```
```text
[addition] is exprtree
├[integer] is exprtree
│└1 is int
├[integer] is exprtree
│└2 is int
├[negative] is exprtree
│└[integer] is exprtree
│ └3 is int
└[addition] is exprtree
 ├[integer] is exprtree
 │└7 is int
 └[negative] is exprtree
  └[integer] is exprtree
   └5 is int
```

Операции должны обязательно иметь правильную функцию парсировки для конвертирования строки в операционное дерево!

#### Конвертация операционного дерева выражения обратно в строку выражения
Алгебра позволяет конвертировать операционные деревья обратно в строки при условии, что грамотно написанны функции представления операций:
```python
print(simple_algebra.to_str(simple_expr))
```
```text
1+2+-3+(7+-5)
```

## Модуль *functree*, его классы, функции и методы
Модуль, дополняющий модуль *exprtree*. Позволяет задавать функции с набором параметров для быстрой подстановки выражений.

### Класс *funcparam* (параметр функции-дерева) и создание его экземпляров
Экземпляры класса *funcparam* - параметры функции. Их можно создать, если подать в конструктор имя параметра:
```python
x = funcparam('x')
```

Параметры нужны для того, чтобы явно задавать параметры функций-деревьев и их порядок.

### Класс *functree* (функция-дерево) и создание его экземпляров
Экземпляры класса *functree* - функции-деревья. Их можно создать, используя готовую алгебру, вызвав метод *new_func* со строко-списком в качестве параметра. Также можно подать готовый список параметров этой функции, чтобы закрепить их порядок. Остальные параметры, которых нет в списке параметров будут добавляться в этот список по мере чтения строко-списка слева-направо. Чтобы обозначить, что данный подстроко-список является именем параметра, нужно обособить его процентами "%". Если в выражении нужно сохранить процент, то можно добавить "\\" перед процентом. Если нужно сохранить символ "\\" в строко-списке, можно добавить символ "\\" перед "\\".
```python
expr_str = 'x+%y%*\\%z\\\\%z%'
expr_SL = stringolist(list(expr_str))   #stringolist(['x', '+', '%', 'y', '%', '*', '\\', '%', 'z', '\\', '\\', '%', 'z', '%'])
# an_algebra - некоторая алгебра, написанная вне этого руководства.
expr = an_algebra.new_expr(expr_SL)     #- функция с параметрами ['y', 'z'] вида: x+y*%z\z
                                        #                                           |    |
                                        #                                          параметры
print(to_str(expr, True))
```
```text
[funcparam(y), funcparam(z)]
[+] is exprtree
├[var] is exprtree
│└x is str
└[\] is exprtree
 ├[*%] is exprtree
 │├y is funcparam
 │└[var] is exprtree
 │ └z is str
 └z is funcparam
```

Так же как и операционные деревья можно создавать копии деревьев-функций:
```python
other_expr = other.copy()
```

Не рекомендуется параметры функции-дерева называть так же, как и другие объекты (например, переменные или константные слова) в этом функции-дереве!

#### Конвертация функции-дерева обратно в строку выражения
Алгебра позволяет конвертировать функции-деревья обратно в строки при условии, что грамотно написанны функции представления операций:
```python
print(an_algebra.to_str(expr))
```
```text
x+y*%z\z
```

Внимание! Параметры функции-дерева могут отображаться так же, как и ваши некоторые объекты! Не создавайте функции-деревья с параметрами похожими на другие объекты функции-дерева, чтобы не путаться в дальнейшем!

#### Подстановка значений вместо параметров
В функцию-дерево вместо некоторых или всех параметров можно подставить определённые значения с помощью метода *subs*, если подать словарь, где в качестве ключей используются строки, в которых записаны имена параметров, вместо которых мы хотим подставить значения, а в качестве ключей - операционные деревья или другие деревья-функции:
```python
expr.subs({'y': simple_expr})
```

Важно! После работы метода функция-дерево меняется, поэтому для сохранения старого функции-дерева перед применением метода нужно создать копию вашего функции-дерева!

## Модуль *exprhandler*, его классы, функции и методы
Модуль, позволяющий создавать предобработки строки перед созданием операционного дерева и постобработки строки после конвертации операционного дерева обратно в строку.

### Функция *invertOperPreparser*
Эта функция позволяет привести операцию в инфиксной форме к префиксной форме. Если у тебя есть операции "+" и "-", где "+" используется только в инфиксной форме "A+B", а "-" может использоваться как в инфиксной форме "A-B", так и в префиксной "-A", при чём "A-B" - это то же самое, что и "A+(-B)", тогда удобно рассматривать "-" как префиксную операцию в выражении и записывать выражения с "-" только так "A+(-B)". Но, если вы допускаете использования "-" как инфиксную операцию, то в таком случае вашей алгебре понадобится функция предобработки строки. Такая функция создаётся через шаблонную функцию *invertOperPreparser* подачей аргументов "-" и "+":
```python
preparseInv = invertOperPreparser('-', '+', ['(', '[', '{']]
```

В качестве третьего аргумента используется список начал выших группирующих операций в вашей алгебре, чтобы префиксные "-" не менять.

Теперь полученная функция подаётся после основной группирующей операции в списке при создании алгебры:
```python
plus = OperInfix('plus', '+')
minus = OperPrefix('minus', '-')
var = OperObject('variable',
                 lambda x: x.is_str() and x.to_str().isidentifier(),
                 lambda x: x.to_str(),
                 lambda x: stringolist(list(x)))
group = {
    x: operGrouping(x, *x)
    for x in ['()', '[]', '{}']
}
algebraPlusMinus = algebra(
    'simple',
    list(group.values()) + [plus, minus, var],
    list(group.values()) + [var, minus, plus],
    group['()'],
    [preparseInv]
)
```

### Функция *invertOperPoststringifier*
Эта функция используется в паре с *invertOperPreparser* и выполняет обратную роль: если вы хотите, чтобы ваше выражение выводилось так "A-B", а не так "A+-B", то нужно создать обработчик, используя эту шаблонную функцию с теми же аргументами, но без третьего:
```python
poststringifyInv = invertOperPoststringifier('-', '+')
```

Тогда та же алгебра, что создавалась с *preparseInv*, будет создаваться так:
```python
plus = OperInfix('plus', '+')
minus = OperPrefix('minus', '-')
var = OperObject('variable',
                 lambda x: x.is_str() and x.to_str().isidentifier(),
                 lambda x: x.to_str(),
                 lambda x: stringolist(list(x)))
group = {
    x: operGrouping(x, *x)
    for x in ['()', '[]', '{}']
}
algebraPlusMinus = algebra(
    'simple',
    list(group.values()) + [plus, minus, var],
    list(group.values()) + [var, minus, plus],
    group['()'],
    [preparseInv],
    [poststringifyInv]
)
```

Наш *poststringifyInv* находится в списке последним аргументом в конструкторе алгебры и служит обработкой перед возвратом выражения в виде строки от метода *to_str*.

## Модуль *transtree*, его классы, функции и методы
Этот модуль позволяет выполнять написанные вами преобразования операционных деревьев.

### Функция *apply*
Главная функция этого модуля, позволяет применить преобразование ко всему операционному дереву. Очень полезна тем, что пользователю не придётся разбираться с работой с деревьями, ведь эта функция сама применяет ваше преобразование к каждой части операционного дерева, начиная с выражений, которые выполняются первыми в вашем основном выражении.

В *apply* подяётся операционное дерево или функция-дерево, которое нужно изменить, и функция преобразования:
```python
expr = apply(expr, trans)
```

Функция *trans* (из примера выше) должна принимать в качестве единственного и обязательного аргумента операционное дерево (или любой другой объект из вашей алгебры, если это значение операции-объекта), а возвращать изменённое или это же операционное дерево (или этот же объект, если он не принадлежит операционным деревьям). В начале алгоритма вашей функции обязательно проверьте принадлежность поданного аргумента к операционным деревьям и верните его, если он не является таковым. Проделайте нужную работу с текущим узлом дерева. У любого узла дерева есть атрибуты *val* и *trees*. В *val* всегда хранится объект класса *operation*, в *trees* хранится список или *None*. В списке *trees* в основном лежат операционные деревья, которые являются аргументами для текущей операции, а для некоторых операций, называемых объектами-операциями (созданные функцией *OperObject* из модуля *exprtree*), *trees* хранит список произвольных объектов и является значением этого объекта-операции. После работы алгоритма верните результат (операционное дерево). В следующем примере создаётся функция, которая находит такие объекты-операции типа *MyInt* и меняет их на объекты-операции типа *MyFloat* с тем же значением, но в представлении этой объекта-операции:
```python
def my_transformation(expr: 'exprtree|any') -> 'exprtree|any'
    """Заменяет все целые числа на вещественные."""
    if not isinstance(expr, exprtree):
        return expr
    if expr.val == MyInt:
        expr.val = MyFloat
        expr.trees[0] = float(expr.trees[0])
    return expr
```

Пусть *expr = any_algebra.new_expr('a+1-b\*(3.0-c\*4)')* и в виде дерева имеет вид:
```text
[MyPlus] is exprtree
├[MyVar] is exprtree
│└a is str
├[MyInt] is exprtree
│└1 is int
└[MyMul] is exprtree
 ├[MyNeg] is exprtree
 │└[MyVar] is exprtree
 │ └b is str
 └[MyPlus] is exprtree
  ├[MyFloat] is exprtree
  │└3.0 is float
  └[MyMul] is exprtree
   ├[MyNeg] is exprtree
   │└[MyVar] is exprtree
   │ └c is str
   └[MyInt] is exprtree
    └4 is int
```
, тогда после выполнения:
```python
expr = apply(expr, my_transformation)
```
получится *expr = any_algebra.new_expr('a+1.0-b\*(3.0-c\*4.0)')* и в виде дерева будет иметь вид:
```text
[MyPlus] is exprtree
├[MyVar] is exprtree
│└a is str
├[MyFloat] is exprtree
│└1.0 is float
└[MyMul] is exprtree
 ├[MyNeg] is exprtree
 │└[MyVar] is exprtree
 │ └b is str
 └[MyPlus] is exprtree
  ├[MyFloat] is exprtree
  │└3.0 is float
  └[MyMul] is exprtree
   ├[MyNeg] is exprtree
   │└[MyVar] is exprtree
   │ └c is str
   └[MyFloat] is exprtree
    └4.0 is int
```

### Функция *operation_sort*
Это шаблонная функция для создания сортировки аргументов внутри указанных вами операций. Если ваша операция является коммутативной, то можно просотртировать аргументы этой операции, не меняя результата выполнения этой функции:
```python
commutative = operation_sort([MyPlus, MyMul])
expr = apply(expr, commutative)
```

Это преобразование бывает полезным, когда нужно сравнить два операционных дерева на равенство после некоторых преобразований. После применения *commutative* ваше операционное дерево примет канонический вид, что в некоторых случаях может сделать изначально неравные деревья равными.

### Функция *expression_replacer*
Это шаблонная функция для создания шаблонной замены по формуле. Для создания функции нужно подать пару (кортеж из двух) функций-деревьев с одинаковым набором параметров:
```python
x_param = funcparam('x')
y_param = funcparam('y')
negBinMulFormula = any_algebra.new_func('-%x%*%y%', [x_param, y_param]), \
                   any_algebra.new_func('-(%x%*%y%)', [x_param, y_param])
negBinMul = expression_replacer(negBinMulFormula)
```

Если *expr = any_algebra.new_expr('a+1.0-b\*(3.0-c\*4.0)')*, который в виде дерева имеет вид:
```text
[MyPlus] is exprtree
├[MyVar] is exprtree
│└a is str
├[MyFloat] is exprtree
│└1.0 is float
└[MyMul] is exprtree
 ├[MyNeg] is exprtree
 │└[MyVar] is exprtree
 │ └b is str
 └[MyPlus] is exprtree
  ├[MyFloat] is exprtree
  │└3.0 is float
  └[MyMul] is exprtree
   ├[MyNeg] is exprtree
   │└[MyVar] is exprtree
   │ └c is str
   └[MyFloat] is exprtree
    └4.0 is int
```

, то после выполнения:
```python
expr = apply(expr, negBinMulFormula)
```

выражение станет *expr = any_algebra.new_expr('a+1.0-(b\*(3.0-(c\*4.0)))')* и в виде дерева будет иметь вид:
```text
[MyPlus] is exprtree
├[MyVar] is exprtree
│└a is str
├[MyFloat] is exprtree
│└1.0 is float
└[MyNeg] is exprtree
 └[MyMul] is exprtree
  ├[MyVar] is exprtree
  │└b is str
  └[MyPlus] is exprtree
   ├[MyFloat] is exprtree
   │└3.0 is float
   └[MyNeg] is exprtree
    └[MyMul] is exprtree
     ├[MyVar] is exprtree
     │└c is str
     └[MyFloat] is exprtree
      └4.0 is int
```

### Функция *neutrals_deleter*
Это шаблонная функция для создания функции удаления нейтральных элементов текущего узла. Для создания функции нужно в шаблонную функцию подать словарь, ключи которого являются именами операций, а значения - списками операционных деревьев, которые в вашей алгебре считаются нейтральными элементами для данной операции:
```python
zeros = [any_algebra.new_expr('0'),
         any_algebra.new_expr('0.0'),
         any_algebra.new_expr('-0'),
         any_algebra.new_expr('-0.0')]
units = [any_algebra.new_expr('1'),
         any_algebra.new_expr('1.0')]
neutral_del = neutrals_deleter({'MyPlus': zeros, 'MyMul': units})
```

Если *expr = any_algebra.new_expr('a+0+(b+0.0)')*, то после следующего кода:
```python
expr = apply(expr, neutral_del)
```

*expr* примет вид *any_algebra.new_expr('a+b')*.

### Функция *zero_absorber*
Это шаблонная функция для создания функции поглащения элементом всей операции. Для создания функции нужно в шаблонную функцию подать словарь, ключи которого являются именами операций, а значения - списками операционных деревьев, которые в вашей алгебре считаются поглащающими данную операцию элементами:
```python
zeros = [any_algebra.new_expr('0'),
         any_algebra.new_expr('0.0'),
         any_algebra.new_expr('-0'),
         any_algebra.new_expr('-0.0')]
absorb = zero_absorber({'MyMul': zeros})
```

Если *expr = any_algebra.new_expr('a\*0+(b\*0.0)+c\*1+d\*2.0')*, то после следующего кода:
```python
expr = apply(expr, absorb)
```

*expr* примет вид *any_algebra.new_expr('0+0+c\*1+d\*2.0')*. При чём все операции, где есть поглащающий эту операцию элемент, заменятся на первый поглащающий элемент из соответствующего списка.
