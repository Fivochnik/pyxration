# **Оглавление**

- [Общая информация](#pyxration)
- [Модуль *stringolist*, его классы, функции и методы](#модуль-stringolist-его-классы-функции-и-методы)
  - [Класс *stringolist* (строко-список) и создание его экземпляров](#класс-stringolist-строко-список-и-создание-его-экземпляров)
    - [Добавление новых объектов в *stringolist*-экземпляр](#добавление-новых-объектов-в-stringolist-экземпляр)
    - [Операции над строко-списками](#операции-над-строко-списками)
    - [Получение объекта по ключу или срезу](#получение-объекта-по-ключу-или-срезу)
    - [Перечисление в цикле *for*](#перечисление-в-цикле-for)
    - [Проверка принадлежности](#проверка-принадлежности)
    - [Поиск объектов и подстроко-списков](#поиск-объектов-и-подстроко-списков)
    - [Замена подстроко-списка другим](#замена-подстроко-списка-другим)
    - [Разбитие строко-списка на строко-списки](#разбитие-строко-списка-на-строко-списки)
- [Модуль *exprtree*, его классы, функции и методы](#модуль-exprtree-его-классы-функции-и-методы)

## *pyxration*
Символьная алгебраическая библиотека для создания и описания своих алгебраических систем.

Позволяет создавать свои операции, объекты, алгебры, использующие эти операции и объекты, и преобразования выражений (переходы от одного выражения к другому).

## Модуль *stringolist*, его классы, функции и методы
Модуль, который позволяет работать со строко-списками - гибрид строки и списка. Является Python-списком, но имеет в себе методы Python-строки. Таким образом можно искать "подсписок" (подстроко-список) у данного строко-списка. Строко-список можно понимать, как Python-строку, которая вместо символов содержит любые объекты.

### Класс *stringolist* (строко-список) и создание его экземпляров
Класс позволяет создавать списки разных элементов и работать с этими списками как со строками. Возможность хранить любые объекты в качестве элементов в *stringolist*-объектах даёт возможность заменять часть строки, представленной в виде *stringolist*-объекта на какой-нибудь обработанный объект.

Для создания строко-списка в конструктор в качестве параметра нужно подать список, либо подать сразу несколько объектов:
```python
s = stringolist(0, 1.1, 'abc', None)            # stringolist([0, 1.1, 'abc', None])
len(s)                                          # 4
helloList = stringolist(list('Hello world!'))   # stringolist(['H', 'e', 'l', 'l', 'o', ' ', 'w', 'o', 'r', 'l', 'd', '!'])
len(helloList)                                  # 12
helloStr = stringolist('Hello world')           # stringolist(['Hello world'])
len(helloStr)                                   # 1
```
Количество параметров, поданных в конструктор, приоритетнее значения первого параметра:
```python
a = stringolist([1, 2, 3], 'abc')   # stringolist([[1, 2, 3], 'abc'])
len(a)                              # 2
b = stringolist([[1, 2, 3]])        # stringolist([[1, 2, 3]])
len(b)                              # 1
```

#### Добавление новых объектов в *stringolist*-экземпляр
Добавление новых элементов производится так же как и в список:
```python
a = stringolist(list('Hell'))   # stringolist(['H', 'e', 'l', 'l'])
a.append('o')
a                               # stringolist(['H', 'e', 'l', 'l', 'o'])
```

#### Операции над строко-списками
Операции сложения и умножения над строко-списками такие же как и над строками или списками в Python.
```python
a = stringolist(1, 2, 3)    # stringolist([1, 2, 3])
b = stringolist(4, 5, 6)    # stringolist([4, 5, 6])
a + b                       # stringolist([1, 2, 3, 4, 5, 6])
a * 3                       # stringolist([1, 2, 3, 1, 2, 3, 1, 2, 3])
b * 0                       # stringolist([])
b * -1                      # stringolist([])
```

#### Получение объекта по ключу или срезу
Получение объекта по ключу или срезу работает как и для строк или списков:
```python
L = ['a', 'b', 'c', 'd', 'e', 'f']
S = stringolist(L.copy())           # чтобы случайно не изменить строко-список через переменную L, делаем её копию
S[0]                                # 'a'
S[3]                                # 'd'
S[-1]                               # 'f'
S[-4]                               # 'c'
S[1:4]                              # stringolist(['b', 'c', 'd'])
S[:2]                               # stringolist(['a', 'b'])
S[3:]                               # stringolist(['d', 'e', 'f'])
S[::2]                              # stringolist(['a', 'c', 'e'])
```

#### Перечисление в цикле *for*
Можно в цикле *for* поработать с каждым объектом данного строко-списка:
```python
nums = stringolist(list(range(10))) # stringolist([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
sqrs = stringolist()                # stringolist([])
for num in nums:
    sqrs.append(num ** 2)
sqrs                                # stringolist([0, 1, 4, 9, 16, 25, 36, 49, 64, 81])
```

#### Проверка принадлежности
Проверка принадлежности работает как для строки:
```python
s = stringolist(0, 'f', 23, 4.5, 'abc', None)   # stringolist([0, 'f', 23, 4.5, 'abc', None])
sub = stringolist('f', 23, 4.5)                 # stringolist(['f', 23, 4.5])
sub in s                                        # True
sub = stringolist('f', 4.5)                     # stringolist(['f', 4.5])
sub in s                                        # False
23 in s                                         # TypeError: must be stringolist, not int
```

#### Поиск объектов и подстроко-списков
Для поиска объектов в строко-списке как в списке используется метод *index*, а для поиска подстроко-списка используются *find* и *rfind*:
```python
s = stringolist(0, 1, 2, 0, 1, 2, 0, 1, 2)      # stringolist([0, 1, 2, 0, 1, 2, 0, 1, 2])
s.index(2)                                      # 2
sub = stringolist(2, 0, 1)                      # stringolist([2, 0, 1])
s.find(sub)                                     # 2
s.rfind(sub)                                    # 5
```

#### Замена подстроко-списка другим
Замена подстрокосписка другим производится методом *replace*. Сам строко-список не изменится. Этот метод работает подобно методу для строки:
```python
s = stringolist(list('apple  orange  watermelon'))  # stringolist(['a', 'p', 'p', 'l', 'e', ' ', ' ', 'o', 'r', 'a', 'n', 'g', 'e', ' ', ' ', 'w', 'a', 't', 'e', 'r', 'm', 'e', 'l', 'o', 'n'])
old = stringolist(list('  '))                       # stringolist([' ', ' '])
new = stringolist(list(', '))                       # stringolist([',', ' '])
s.replace(old, new)                                 # stringolist(['a', 'p', 'p', 'l', 'e', ',', ' ', 'o', 'r', 'a', 'n', 'g', 'e', ',', ' ', 'w', 'a', 't', 'e', 'r', 'm', 'e', 'l', 'o', 'n'])
new = stringolist(list(' '))                        # stringolist([' '])
s.replace(old, new)                                 # stringolist(['a', 'p', 'p', 'l', 'e', ' ', 'o', 'r', 'a', 'n', 'g', 'e', ' ', 'w', 'a', 't', 'e', 'r', 'm', 'e', 'l', 'o', 'n'])
```

#### Разбитие строко-списка на строко-списки
Разбитие строко-списка на строко-списки производится методом *split*, как это делается и для строк:
```python
s = stringolist(list('apple  orange  watermelon'))  # stringolist(['a', 'p', 'p', 'l', 'e', ' ', ' ', 'o', 'r', 'a', 'n', 'g', 'e', ' ', ' ', 'w', 'a', 't', 'e', 'r', 'm', 'e', 'l', 'o', 'n'])
sep = stringolist(list('  '))                       # stringolist([' ', ' '])
s.split(sep)                                        # [stringolist(['a', 'p', 'p', 'l', 'e']), stringolist(['o', 'r', 'a', 'n', 'g', 'e']), stringolist(['w', 'a', 't', 'e', 'r', 'm', 'e', 'l', 'o', 'n'])]
```

## Модуль *exprtree*, его классы, функции и методы
Модуль, который позволяет создавать свои операции, строить с помощью них алгебру и задавать выражения с помощью уже алгебры.

### Класс *operation* (операция) и создание его экземпляров
Экземпляры класса *operation* - операции или объекты. Их можно создать, если подать в конструктор имя операции или объекта (и функции парсировки и представления операции или объекта в строковом выражении, если они имеются):
```python
addition = operation('addition')
multiplication = operation('multiplication')
```

При создании своей функции парсировки операции или объекта нужно учитывать, что эта функция должна принимать только строко-список, а возвращать строко-список или операционное дерево (о нём позже), если функция нашла в строко-списке вашу операцию или объект и произвела замену всего строко-списка или частично, иначе - *None*.

При создании своей функции представления операции или объекта нужно учитывать, что эта функция должна принимать только список операционных деревьев, а возвращать строку - строковое представление применения операции к списку объектов.

Для добавления функции парсировки и представления операции достаточно подать эти функции в метод "funcs_update" по одному или в кортеже. Есть готовые шаблоны этих функций, можно воспользоваться ими:
```python
addition.funcs_update(infix_parser_and_repres('+', addition))
multiplication.funcs_update(infix_parser_and_repres('*', multiplication))
```

Для быстрого создания операции или объекта можно воспользоваться готовыми функциями:
```python
plus = operInfix('addition', '+')
minus = operPrefix('negative', '-')
group = operGrouping('()', '(', ')')
integer = operObject('integer',
                     lambda x: x.is_str() and x.to_str().isdigit(),
                     lambda x: int(x.to_str()),
                     lambda x: str(x))
```

### Класс *exprtree* (операционное дерево) и создание его экземпляров
Экземпляры класса *exprtree* - операционные деревья выражений. Их можно создать, если подать в конструктор операцию и список операционных деревьев (если текущая операция - объект, то в качестве списка операционных деревьев подаётся одноэлементный список со значением текущего объекта):
```python
unit = exprtree(integer, [1])
sum_expr = exprtree(plus, [unit.copy(), unit.copy(), unit.copy()])
```

#### Вывод операционного дерева
Функция *str_tree* вернёт строковое представления операционного дерева выражения на боку. Можно подать в качестве дополнительного параметра *True*, чтобы получить типы объектов:
```python
print(str_tree(sum_expr))
```
```text
[addition]
├[integer]
│└1
├[integer]
│└1
└[integer]
 └1
```
```python
print(str_tree(sum_expr, True))
```
```text
[addition] is exprtree
├[integer] is exprtree
│└1 is int
├[integer] is exprtree
│└1 is int
└[integer] is exprtree
 └1 is int
```

### Класс *algebra* (алгебра) и создание его экземпляров
Экземпляры класса *algebra* - алгебры со своими операциями и правилами. Их можно создать, если подать в конструктор имя алгебры и список операций, который задаёт порядок парсировки этих операций в строковом выражении. Также можно подать список операций, который задаёт порядок выполнения выражения, и группирующую операцию, чтобы сгруппировать подвыражения при конвертации из операционного дерева в строку, тем самым задав порядок выполнения выражения.
```python
simple_algebra = algebra('simple', [group, plus, minus, integer], [integer, minus, plus, group], group)
```

#### Создание операционного выражения
Алгебры используются для создания операционных деревьев из строки. Для этого нужно сначала создать операции как написано выше, затем создать алгебру из этих операций, после этого можно создавать операционные деревья из строки с помощью метода *new_expr*:
```python
simple_expr = simple_algebra.new_expr('1+2+-3+(7+-5)')
print(str_tree(simple_expr))
```
```text
[addition] is exprtree
├[integer] is exprtree
│└1 is int
├[integer] is exprtree
│└2 is int
├[negative] is exprtree
│└[integer] is exprtree
│ └3 is int
└[addition] is exprtree
 ├[integer] is exprtree
 │└7 is int
 └[negative] is exprtree
  └[integer] is exprtree
   └5 is int
```

#### Конвертация операционного дерева выражения обратно в строку выражения
Алгебра позволяет конвертировать 

## functree и его основные методы
Модуль, дополняющий модуль **exprtree**. Позволяет задавать функции с набором параметров для быстрой подстановки выражений.

### Класс *funcparam*
Экземпляры класса *funcparam* - параметры функции. Их можно создать, если подать в конструктор имя параметра. В дальнейшем можно подать списком в конструктор функции, чтобы закрепить их порядок в функции.
```python
x = funcparam('x')
```

### Класс *functree*
Экземпляры класса *functree* - функции-деревья. Их можно создать, используя готовую алгебру, вызвав метод *new_func* со строко-списком в качестве параметра. Также можно подать готовый список параметров этой функции, чтобы закрепить их порядок. Остальные параметры, которых нет в списке параметров будут добавляться в этот список по мере чтения строко-списка слева-направо. Чтобы обозначить, что данный подстроко-список является именем параметра, нужно обособить его процентами "%". Если в выражении нужно сохранить процент, то можно добавить "\\" перед процентом. Если нужно сохранить символ "\\" в строко-списке, можно добавить символ "\\" перед "\\".
```python
expr_str = 'x+%y%*\\%z\\\\%z%'
expr_SL = stringolist(list(expr_str))   #stringolist(['x', '+', '%', 'y', '%', '*', '\\', '%', 'z', '\\', '\\', '%', 'z', '%'])
expr = an_algebra.new_expr(expr_SL)     #- функция с параметрами ['y', 'z'] вида: x+y*%z\\z
                                        #                                           |     |
                                        #                                          параметры
```
